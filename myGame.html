<!DOCTYPE html>
<html>

<head>
   <title></title>
   <style type="text/css">
      .header {
         padding: 4px;
      }

      .content {
         margin-top: 10px;
      }

      .menu {
         position: absolute;
         display: flex;
         bottom: 150px;
         margin: 0 20px;
      }

      .figure {
         position: absolute;
         left: 200px;
         top: 200px;
      }

      .estimated-figure {
         position: absolute;
      }

      @keyframes _fallDown {
         0% {
            opacity: 1;
            visibility: visible;
            height: 0%;
            border-bottom-left-radius: 90%;
            border-bottom-right-radius: 90%;
         }

         10% {
            height: '10%';
            border-bottom-right-radius: 100%;
            border-bottom-left-radius: 100%;
         }

         50% {
            height: '50%';
            border-bottom-left-radius: 70%;
            border-bottom-right-radius: 70%;
         }

         100% {
            height: 100%;
            ;
            border-bottom-right-radius: 0%;
            border-bottom-left-radius: 0%;
         }
      }

      @keyframes _fallUp {
         0% {
            height: 100%;
            border-bottom-right-radius: 0%;
            border-bottom-left-radius: 0%;
         }

         50% {
            height: '50%';
            border-bottom-left-radius: 70%;
            border-bottom-right-radius: 70%;
         }

         90% {
            height: '10%';
            border-bottom-right-radius: 100%;
            border-bottom-left-radius: 100%;
         }

         100% {
            opacity: 0;
            visibility: hidden;
            height: 0%;
            border: none;
            box-shadow: none;
         }
      }

      #backdrop {
         width: 100%;
         margin-top: -20px;
         margin-left: -20px;;
         position: absolute;
         background-color: #030e1d;
         transition: all 4s ease-in;
      }

      .fallDown {
         animation: _fallDown .4s ease-in-out;
         animation-fill-mode: forwards;
      }

      .fallUp {
         animation: _fallUp .4s ease-in-out;
         animation-fill-mode: forwards;
      }

      body {
         background: #293039;
         overflow: hidden;
      }

      .menu-buttons {
         position: absolute;
         width: 240;
         top: 20%;
         left: calc(50% - 120px);
      }

      .menu-button {
         width: 240px;
         padding: 4px;
         margin-top: 10px;
         background-color: #52403B;
         border-radius: 50px;
         cursor: pointer;
      }

      .inner-button {
         margin: 5px;
         width: calc(100% - 20px);
         border-radius: 50px;
         border: .2rem solid yellow;
      }

      .button-background {
         background-color: #2D221F;
         border-radius: 50px;
         padding: 6px;
         text-align: left;
         transition: all .4s ease-in;
      }

      .circle {
         width: 20px;
         height: 20px;
         border-radius: 50%;
         background: yellow;
         margin-left: 5px;
         margin-right: 10px;
      }

      .text {
         width: 70%;
         text-align: center;
         font-family: 'Courier New', Courier, monospace;
         font-weight: bold;
         padding: 1px;
         color: white;
      }

      .menu-button:hover .button-background {
         background: #110E0F;
      }

      .d-none {
         display: none;
         color: #4d7a7a;
      }

      .navbar {
         margin: 0;
         padding: 0;
         position: absolute;
         width: 100%;
         height: 60px;
         top: 0;
         left: 0;
         background: #0E1318;
         display: flex;
      }

      .my-font {
         font-family: 'Courier New', Courier, monospace;
         color: white;
      } 

      .score {
         margin-left: auto; 
         margin-right: 5%;
         display: flex;
         padding: 10px;
         font-weight: bolder;
      }

      .best {
         color: orange;
         text-shadow: 2px 2px 4px #0E1318;
      }

      /* #0E1318 */
   </style>

   <script>
      "use strict";

      function $(id) {
         return dom.getElementById(id)
      }

      function dd(text) {
         $('dd').innerText = text
      }

      function vv(text) {
         $("vv").innerText = text
      }

      function attach(obj, ev, fn) {
         obj.addEventListener(ev, fn)
      }

      function detach(obj, ev, fn) {
         obj.removeEventListener(ev, fn)
      }

      function setStyle(el, style) {
         for (let a in style) {
            el.style[a] = style[a]
         }
      }

      function elt(el, cls, id, style) {
         let elm = dom.createElement(el)
         if (cls) elm.className = cls
         if (id) elm.setAttribute('id', id)
         if (style) setStyle(elm, style)
         return elm
      }
   </script>

   <script>

      const userAgent = navigator.userAgent.toLowerCase();
      const Android = userAgent.indexOf("android") > -1;

   </script>

   <script type="text/javascript">

      const CONFIG = {
         android: {
            click: 'touchstart',
            move: 'touchmove',
            end: 'touchend'
         },
         ps: {
            click: 'mousedown',
            move: 'mousemove',
            end: 'mouseup'
         },
         get(type) {
            if (Android) {
               if (!this.android[type]) {
                  throw new Exception(`${type} is not defined`)
               }
               return this.android[type]
            }
            if (!this.ps[type]) {
               throw new Exception(`${type} is not defined`)
            }
            return this.ps[type];
         },
         coords(e) {
            if (Android) {
               return { x: e.touches[0].clientX, y: e.touches[0].clientY }
            }
            return { x: e.clientX, y: e.clientY }
         },
         getScreenWidth() {
            if (Android) {
               let ratio = window.devicePixelRatio || 1;
               return screen.width * ratio;
            }
            return window.innerWidth;
         },
         getScreenHeight() {
            if (Android) {
               let ratio = window.devicePixelRatio || 1;
               return screen.height * ratio;
            }
            return window.innerHeight
         }
      }

      class State {
         figure = null

         type = null       // This is Figure name. For example TYPE_1, TYPE_2, ... 

         boxDiv = null     // This is reference to Div element 

         boxCoords = null  // This is coordinates of the found box

         isDrawable = {}   // Checks, whether or not figure can be drawn, e.g. there is enough place to put it.. 

         allFigures = []   // Current figures that need to be drawn

         set(obj) {
            for (let a in obj) {
               this[a] = obj[a]
            }
         }

         reset() {
            this.figure = null;
            this.type = null;
            this.boxDiv = null;
            this.boxCoords = null;
            this.isDrawable = {};
            this.allFigures = [];
         }
      }

      let state = new State()

      const FIGURES = {
         TYPE_1: {
            figure:
               `
              ###
              #
              #
            `,
         },

         TYPE_2: {
            figure:
               `
              ##
              ##
            `,
         },

         TYPE_3: {
            figure:
               `
              ##
              #
            `,
         },

         TYPE_4: {
            figure:
               `
              ###
            `,
         },

         TYPE_5: {
            figure:
               `
              #
              #
              #
            `,
         },

         TYPE_6: {
            figure:
               `
              ###
              ###
              ###
            `,
         },

         TYPE_7: {
            figure:
               `
              #####
            `,
         },

         TYPE_8: {
            figure:
               `
              ####
            `,
         },

         TYPE_9: {
            figure:
               `
              #
              #
              #
              #
            `,
         },

         TYPE_10: {
            figure:
               `
             .#
             ##
            `
         }

      }

      class PlaceFinder {

         RUN_SLOW = 'runSLow';
         type = null;
         found = false;

         check(figureType, figure, divElement) {
            this.type = figureType;
            this.run(this.RUN_SLOW, { figure, divElement })
         }

         checkAll(figures) {
            this.found = false;
            figures.forEach(figure => {
               this.check(figure.type, figure.figure, figure.div)
            })
            if (!this.found) {
               game.lose();
            }
         }

         run(TYPE, { figure, divElement }) {
            const can = this.runSlow(figure)
            this.update(can, divElement)
         }

         runSlow(figure) {
            let found = false;
            for (let i = 0; i < boxesOnRow && !found; i++) {
               for (let j = 0; j < boxesOnColumn && !found; j++) {
                  let can = this.tryToFit({ i, j }, figure)
                  if (can) found = true;
               }
            }
            return found;
         }

         tryToFit({ i, j }, figure) {
            return painter.canBeDrawn({ x: i, y: j }, figure)
         }

         update(status, div) {
            state.isDrawable[this.type] = status;
            if (!status) {
               setStyle(div, {
                  opacity: '.3'
               })
            }
            else {
               this.found = true;
               setStyle(div, {
                  opacity: '1'
               })
            }
         }

      }

      let placeFinder = new PlaceFinder();

      class Figure {
         static scaleK = 3;
         cnt = null;

         constructor() {
            this.reset();
         }

         removeFigure() {
            setStyle(state.boxDiv, {
               visibility: 'hidden'
            })
            if (--this.cnt === 0) {
               this.cnt = 3;
               Figure.drawFigures();
            }
         }

         static getRandomFigures(cnt = 3) {
            let keys = Object.keys(FIGURES);
            let len = keys.length;
            let randomFigures = [];

            for (let i = 0; i < cnt; i++) {
               let ind = Math.floor(Math.random() * len);
               randomFigures.push(keys[ind]);
            }
            return randomFigures;
         }

         static drawFigures() {
            $('menu').innerHTML = "";

            let randomFigures = Figure.getRandomFigures();
            randomFigures.forEach(figureType => {
               Figure.drawFigure(figureType)
            })
            placeFinder.checkAll(state.allFigures)
         }

         static drawFigure(figureType) {
            let type = figureType;
            figure = FIGURES[type].figure
            figure = figure.split("\n")
               .map(c => c.trim())
               .filter(c => c)
               .map(c => c.split(""))

            let marginLeft = width / 6.4 + 'px';
            let box = elt("box", null, null, {
               position: "relative",
               marginLeft: marginLeft,
               marginRight: marginLeft
            })

            const bw = boxWidth / Figure.scaleK;
            const bh = boxHeight / Figure.scaleK;

            Figure.draw(figure, bw, bh, box)
            Event.register(box, figure, type)

            state.allFigures.push({
               type: figureType,
               figure,
               div: box,
            })

            $("menu").append(box)
         }

         static draw(figure, bw, bh, box, style = {}) {
            figure.forEach((r, i) => {
               r.forEach((c, j) => {
                  if (figure[i][j] !== ".") {
                     let l = j * (bw + 3);
                     let t = i * (bh + 3);

                     let el = elt("div", null, null, {
                        top: t + "px",
                        left: l + "px",
                        width: bw + "px",
                        height: bh + "px",
                        background: boxColor,
                        position: "absolute",
                     })
                     setStyle(el, style)
                     box.append(el);
                  }
               })
            })
         }

         reset() {
            this.cnt = 3;
         }
      }

      let figureHelper = new Figure();

      class Finder {
         x = null
         y = null
         len = null;
         prevBox = null;
         backTrack = false;

         constructor() {
            this.reset();
         }

         reset() {
            this.x = this.y = this.len = 4;
            this.shown = false;
         }

         getNextPartition() {
            let type = this.len;

            if (type == 4) {
               return 2;
            } else if (type == 3) {
               return 1;
            } else {
               return 1;
            }
         }

         update(typeX, typeY) {
            if (this.len === 1) {
               if (typeX == 1) typeX = 0;
               if (typeY == 1) typeY = 0;
            }

            if (this.backTrack) {
               setStyle(boxesArray[this.x][this.y].div, {
                  background: 'rgba(200, 0, 0, .3)'
               })
            }

            let len = this.getNextPartition();

            if (typeX == '-1') {
               this.y -= len
            } else if (typeX == '1') {
               this.y += len
            }

            if (typeY == '-1') {
               this.x -= len
            } else if (typeY == '1') {
               this.x += len
            }

            this.len /= 2;
            if (this.len < 1) this.len = 0;

            // if (this.len === 0) this.matchBox();
         }

         isDone() {
            return this.len === 0;
         }

         getX() {
            return boxesArray[this.x][this.y].x;
         }

         getY() {
            return boxesArray[this.x][this.y].y;
         }

         getCoords() {
            let coords = boxesArray[this.x][this.y];
            return { x: coords.x, y: coords.y }
         }

         matchBox() {
            if (this.prevBox) {
               setStyle(this.prevBox, {
                  background: 'rgba(0,0,0,.02)',
               })
            }
            let div = boxesArray[this.x][this.y].div;

            setStyle(div, {
               background: 'red',
            })
            this.prevBox = div;
         }

      }

      let finder = new Finder();

      class Painter {
         canDraw = false;

         drawTmpFigure({ x, y }, figure) {
            this.canDraw = this.canBeDrawn({ x, y }, figure);
            if (!this.canDraw) {
               this.clearTmpFigure();
               return;
            }

            let box = $('estimated-figure')
            let block = boxesArray[x][y];
            let [x1, y1] = [block.x, block.y];

            setStyle(box, {
               left: x1 + 'px',
               top: y1 + 'px',
               opacity: .4
            })

            Figure.draw(figure, boxWidth * .97, boxHeight * .97, box)
         }

         clearTmpFigure() {
            $('estimated-figure').innerHTML = "";
         }

         canBeDrawn({ x, y }, figure) {
            if (x == undefined || y == undefined) {
               return false;
            }

            let lx = 0, ly = 0;
            let busy = false;

            figure.forEach((r, i) => {
               if (busy) return;
               r.forEach((c, j) => {
                  if (busy) return;
                  if (figure[i][j] !== '.') {
                     lx = Math.max(lx, i);
                     ly = Math.max(ly, j);
                     if (i + x < boxesOnRow && j + y < boxesOnColumn) {
                        if (boxesArray[x + i][y + j].busy == 1) {
                           busy = true;
                        }
                     } else {
                        busy = true;
                     }
                  }
               })
            })

            let can = ((x + lx) < boxesOnRow) && ((y + ly) < boxesOnColumn);
            if (busy) {
               can = false;
            }
            // this.canDraw = can;

            return can;
         }

         tryToDraw() {
            this.clearTmpFigure();
            if (state.boxCoords && state.figure) {
               this.canDraw = this.canBeDrawn(state.boxCoords, state.figure)
            } else {
               this.canDraw = false;
            }
            if (!this.canDraw) {
               return;
            }
            this.draw();
            figureHelper.removeFigure();
            this.update()
         }

         draw() {
            let figure = state.figure;
            let { x, y } = state.boxCoords;

            figure.forEach((r, i) => {
               r.forEach((c, j) => {
                  if (figure[i][j] !== '.') {
                     setStyle(boxesArray[x + i][y + j].div, {
                        background: boxColor,
                     })
                     //  console.log("updated")
                     remover.update({ x: x + i, y: y + j });
                  }
               })
            })
            remover.cleanUp()
         }

         update() {
            let removed = false;
            state.allFigures = state.allFigures.filter(({ type }) => {
               if (removed) return true;
               removed = (type === state.type)
               return !removed
            })
            state.isDrawable = {}
            placeFinder.checkAll(state.allFigures)
            // console.log(state.isDrawable)
            score.update()
         }
      }

      let painter = new Painter();

      class Score {
          score = 0;
          maxScore = 0;

          async update(score = 15) {
            const num = Math.floor(Math.random() * score) + 7
            const parts = Math.floor(Math.random() * 7)

            this.score += num;

            for (let i=0; i< parts; i++) {
               await this.add(Math.floor(num / parts))
            }
         }

          add(cnt) {
              return new Promise((res, rej) => {
                 setTimeout(() => {
                    let score = $('score').innerText
                    score = parseInt(score)
                    score += cnt 
                    $('score').innerText = score.toString()
                    res()
                 }, 70)
              })
         }

          reset() {
            this.score = 0;
            $('score').innerText = '0';
            this.maxScore = this.getMaxScore();
            $('max-score').innerText = this.maxScore;
         }

          getMaxScore() {
            let score = !!localStorage.getItem('max-score') ? localStorage.getItem('max-score') : 0;
            return score.toString();
         }

          updateMaxScore() {
            if (this.score > this.maxScore) {
               localStorage.setItem('max-score', this.score)
            }
         }
      }

      const score = new Score();

      class Remover {
         onRow = [];
         onColumn = [];

         constructor() {

         }

         update({ x, y }) {
            if (this.onColumn[y]) {
               this.onColumn[y]++;
            } else {
               this.onColumn[y] = 1;
            }

            if (this.onRow[x]) {
               this.onRow[x]++;
            } else {
               this.onRow[x] = 1;
            }

            boxesArray[x][y].busy = true;
         }

         cleanUp() {
            let removedColumns = 0;
            let isRemoved = false;
          
            for (let i = 0; i < boxesOnColumn; i++) {
               if (this.onColumn[i] === boxesOnColumn) {
                  this.remove(i, boxesOnRow, 'row');
                  removedColumns++;
                  this.onColumn[i] = 0;
                  if (!isRemoved) isRemoved = true;
               }
            }

            for (let i = 0; i < boxesOnRow; i++) {
               if (this.onRow[i] === boxesOnRow) {
                  this.remove(i, boxesOnColumn, 'column', (i) => {
                     if (this.onColumn[i]) {
                        this.onColumn[i]--;
                     }
                  })
                  this.onRow[i] = 0;
                  if (!isRemoved) isRemoved = true;
               }
               else {
                  this.onRow[i] -= removedColumns;
               }
            }

            if (isRemoved) score.update(50)
            // console.log("column", this.onColumn);
            // console.log("row", this.onRow);
         }

         remove(a, b, type, fn) {
            for (let i = 0; i < b; i++) {
               let box = boxesArray[i][a];
               if (type === 'column') box = boxesArray[a][i];

               if (fn) fn(i);

               if (!box.busy) continue;
               box.busy = false;

               setStyle(box.div, {
                  background: blockCrashColor,
               })

               setTimeout(() => {
                  setStyle(box.div, {
                     background: '#1E1E1E',
                     border: '2px solid black'
                  })
               }, 300)
            }
         }

         reset() {
            this.onColumn = [];
            this.onRow = [];
         }

      }

      let remover = new Remover();

      class Layout {
         static init() {
            Layout.initBoxes()
            Layout.createLayout();
         }

         static initBoxes() {
            boxesArray = [];
            for (let i = 0; i < boxesOnColumn; i++) {
               boxesArray.push([])
               for (let j = 0; j < boxesOnRow; j++) {
                  let x = j * (boxWidth + 1) + offsetX
                  let y = i * (boxHeight + 1) + offsetY
                  boxesArray[i].push({ x, y })
               }
            }
         }

         static createLayout() {
            $("content").innerHTML = "";

            for (let i = 0; i < boxesOnColumn; i++) {
               for (let j = 0; j < boxesOnRow; j++) {
                  let box = boxesArray[i][j]
                  Layout.createSingleBlock(box)
               }
            }
         }

         static createSingleBlock(box) {
            let el = elt('div', "box", null, {
               position: 'absolute',
               width: (boxWidth + 0) + "px",
               height: (boxHeight + 0) + "px",
               left: box.x + 'px',
               top: box.y + 'px',
               background: '#1E1E1E',                //rgba(0,0,0,.02)
               border: '2px solid black'       //1px solid rgba(0,0,0,.051)
            })

            el.onmousedown = (e) => e.preventDefault()

            $("content").append(el)

            box.div = el
            box.busy = 0
         }
      }

      class Event {

         static register(box, figure, type) {
            let mousePressed = null;

            function update(ev) {
               moveFigure(ev)
               BoxFinder.findAndDraw(ev)
            }

            function moveFigure(e) {
               let { x, y } = CONFIG.coords(e);
               x = x + figureOffsetX + 'px';
               y = y + figureOffsetY + 'px';

               setStyle($("figure"), {
                  left: x,
                  top: y,
               })
            }

            function clickEvent(e) {
               e.preventDefault();
               if (!state.isDrawable[type] || game.finished) return;
               mousePressed = true;

               state.set({
                  figure,
                  boxDiv: box,
                  type,
                  boxCoords: null
               })

               Figure.draw(figure, boxWidth * .96, boxHeight * .96, $("figure"),
               {
                  background: boxColor,
                  border: '2px solid grey',
                  borderRadius: '3px',
               })
               setStyle(box, {
                  opacity: .3,
               })
               update(e)
            }

            function endEvent(e) {
               if (!state.isDrawable[type] || game.finished) return;
               setStyle(box, {
                  opacity: "1"
               })
               $("figure").innerHTML = ""
               if (mousePressed) {
                  painter.tryToDraw();
                  mousePressed = false;
               }
            }

            attach(box, CONFIG.get('click'), (e) => {
               clickEvent(e);
               attach(dom, CONFIG.get("move"), update)
               attach(dom, CONFIG.get("end"), end)
            })

            function end(ev) {
               endEvent(ev);
               detach(dom, CONFIG.get("move"), update)
               detach(dom, CONFIG.get("end"), end)
            }
         }
      }

      class BoxFinder {
         static findAndDraw(e) {
            let { x, y } = CONFIG.coords(e);

            x = x + figureOffsetX;
            y = y + figureOffsetY;

            state.status = "finding";
            let sbox = BoxFinder.bestBox({ x, y })
            if (sbox === -1) {
               painter.clearTmpFigure()
            }
            state.status = "found";
         }

         static bestBox({ x, y }) {
            let errorX = boxWidth / 2;
            let errorY = 10;

            if (x < offsetX - errorX) {
               console.log("X < 0");
               painter.clearTmpFigure();
               return -1;
            }

            if (y < offsetY - errorY) {
               console.log("Y < 0");
               painter.clearTmpFigure();
               return -1;
            }


            while (true) {
               if (finder.isDone()) {
                  state.boxCoords = { x: finder.x, y: finder.y }
                  painter.drawTmpFigure({ x: finder.x, y: finder.y }, state.figure)
                  finder.reset()
                  break;
               }
               let coords = finder.getCoords();
               let [x1, y1] = [coords.x, coords.y]
               let typeX = null, typeY = null;

               if (x - errorX < x1) typeX = '-1';
               if (x >= x1 - errorX) typeX = '1';
               if (y - errorY < y1) typeY = '-1';
               if (y >= y1 - errorY) typeY = '1';

               finder.update(typeX, typeY);
            }
         }
      }

      class Game {
         finished = false;

         start() {
            this.reset()
            Menu.hide();
            Layout.init();
            Figure.drawFigures()
         }

         lose() {
            this.finished = true;
            score.updateMaxScore();
            setTimeout(async () => {
               Menu.show()
            }, 700)

         }

         reset() {
            score.reset()
            state.reset();
            remover.reset();
            figureHelper.reset();
            this.finished = false;
         }
      }

      class Menu {
         static show() {
            $('backdrop').className = 'fallDown'
         }

         static hide() {
            $('backdrop').className = 'fallUp'
         }

         static init() {
            ['start', 'options', 'upgrade', 'about'].forEach(button => {
               let result = `
                  <div class='menu-button' onclick='game.start()'>
                     <div class='inner-button'>
                        <div class='button-background'>
                           <div style='display:flex'>
                              <div class='circle'></div>
                              <span class='text'>
                                  ${button}
                              </span>
                           </div>
                        </div>
                  </div>
               </div>`

               $('menu-buttons').innerHTML += result
            })
         }
      }

   </script>
</head>

<body>
   <p id="dd"></p>
   <p id="vv"></p>

   <div class='fallDown' id='backdrop' style="z-index: 1;">
      <div class='menu-buttons' id='menu-buttons'>

      </div>
   </div>

   <div class='navbar'>
      <img src='images/log.png' height='40' style='margin: 5px;margin-left: 5%;' />
      <p class='my-font' style='margin-left: 15px; padding-top: 3px'> My Game </p>
      <div class='score'>
          <p class='my-font best' id='max-score' style='margin-right: 20px'> -- </p>
          <img src='/images/trophy.png' height="40" style='padding-top: 3px'/>
          <p class='my-font' id='score' style='margin-left: 20px' > 0 </p> 
      </div>
   </div>

   <div class="header" id="header">

   </div>

   <div class="content" id="content">

   </div>

   <div class="menu" id="menu" onclick="event.preventDefault()">

   </div>

   <div class="figure" id="figure">

   </div>

   <div class='estimated-figure' id='estimated-figure'>

   </div>

   <script>
      const dom = document;
      const width = CONFIG.getScreenWidth() * .9;
      const height = CONFIG.getScreenHeight();
      const offsetY = height * 0.1;
      let offsetX = 0;
      const boxesOnRow = 8;
      const boxesOnColumn = 8;
      let boxHeight = (height * .7) / boxesOnColumn;
      let boxWidth = (width - offsetX) / boxesOnRow
      boxWidth = boxHeight = Math.min(boxWidth, boxHeight);
      let boxesArray = [];
      const figureOffsetX = -70
      const figureOffsetY = -200
      const boxColor = 'rgba(153, 93, 93)';
      const blockCrashColor = 'rgba(102, 46, 11)';
   </script>

   <script type="text/javascript">
      {
         let roffsetX = offsetX + boxesOnRow * boxWidth
         roffsetX = width - roffsetX;
         offsetX = (offsetX + roffsetX) / 2 + 20;
      }

      
      let game = new Game();
      Menu.init()
      

   </script>
</body>

</html>